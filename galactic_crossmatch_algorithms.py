# -*- coding: utf-8 -*-
"""Galactic_Crossmatch_Algorithms.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ycBMyCsYl5n-o-W5gXBb0wFsEWkJrJXC
"""

#Compares Astronomical Objects from the optical and radio galaxies of the SuperCOSMOS and BSS datasets, respectively, to validate the object positions and presence 
#Link to BSS Dataset: http://cdsarc.u-strasbg.fr/viz-bin/Cat?J/MNRAS/384/775
#Link to SuperCOSMOS Dataset: 
import numpy as np

def hms2dec(hour, minute, second): #used to convert hand/minute/second directions to right ascension coordinates
  hour_time = hour + minute/60 + second/3600
  return(hour_time*15)

def dms2dec(degree, arcminute, arcsecond): #used to convert degree/arcmin/arcsec directions to declination coordinates
  degree_time = abs(degree)+ arcminute/60 + arcsecond/3600
  if degree < 0:
    return(-degree_time)
  else:
    return(degree_time)
  
def import_bss(bss_data): #imports and shows the BSS Catalogue --> need to use conversion functions
  cat = np.loadtxt(data, usecols=range(1, 7))
  cat_indexed = []
  for i in range(len(cat)):
    cat_indexed.append((i+1,hms2dec(cat[i,0],cat[i,1],cat[i,2]),dms2dec(cat[i,3],cat[i,4],cat[i,5])))
  return(cat_indexed)

def import_super(super_data): #imports and shows the SuperCOSMOS Catalogue --> no conversion functions necessary
  cat = np.loadtxt(super_data, delimiter=',', skiprows=1, usecols=[0, 1])
  cat_indexed = []
  for i in range(len(cat)):
    cat_indexed.append((i+1,cat[i,0],cat[i,1]))
  return(cat_indexed)

def angular_dist(right_ascension1, declination1, right_ascension2, declination2): #returns the projected angular distance from earth on the celestial sphere
  ra1_rad = np.radians(right_ascension1)
  dc1_rad = np.radians(declination1)
  ra2_rad = np.radians(right_ascension2)
  dc2_rad = np.radians(declination2)
  arg1 = np.sin(abs(dc1_rad - dc2_rad)/2)**2 #declination sine arguments
  arg2 = np.cos(dc1_rad)*np.cos(dc2_rad)*(np.sin(abs(ra1_rad - ra2_rad)/2)**2) #declination and right ascention arguments
  ang_rad = 2*np.arcsin(np.sqrt(arg1+arg2)) #haversine formulation
  ang_deg = np.degrees(ang_rad)
  return ang_deg

def find_closest(bss_catalogue, right_inclination, declination): #finds closest astronomical object given a target coordinate
  distance_catalogue = []
  for i in range(len(bss_catalogue)):
    angdis = angular_dist(bss_catalogue[i][1],bss_catalogue[i][2],right_inclination,declination)
    distance_catalogue.append((i+1,angdis))
  distance_array = np.array(distance_catalogue) #turn the catalogue into an array
  sorted_distance_array = distance_array[np.argsort(distance_array[:, 1])] #sorts the array by angular distance
  return (int(sorted_distance_array[0,0]), sorted_distance_array[0,1])
  

def crossmatch(bss_cat,super_cat,max_dist): #crossmatches astronomical objects between catalogues to a threshold distance
  match = [] #will contain the ID of the bss_cat, the super_cat and the angular distance
  no_match = [] #will only contain the ID of the bss_cat
  
  for i in range(len(bss_cat)): #use of the bss_system coordinates
    mcount = 0
    bss_r = bss_cat[i][1]
    bss_d = bss_cat[i][2]
    min_dis = 0
    for j in range(len(super_cat)):
      super_r = super_cat[j][1]
      super_d = super_cat[j][2]
      angdis = angular_dist(bss_r, bss_d, super_r, super_d)
      if angdis < max_dist and angdis > min_dis:
        min_dis = np.sqrt(angdis)
        match.append((bss_cat[i][0],super_cat[j][0],angdis))
        mcount+=1
    if mcount ==0:
      no_match.append(bss_cat[i][0])
  return (match, no_match)

#crossmatching naively across many large datasets and catalogues is very tenuous in terms of time due to the number of calculations
#largest improvement to be made (aside from numpy vectorization is to improve the search technique)

#--> this function will sort the cross match by the min/max possible distances from an object in catalogue 1; will use binary search tree to find the max/min thresholds
def crossmatch_box(max_radius,
                   cat1, #first catalogue of objects - will not be altered
                   cat2): #second catalogue of objects - will have the binary search applied to reduce number of validations
    start_time = time()
    deg2rad = np.pi/180
    rad2deg = 180/np.pi
    matches = []
    no_matches = []
    
    # Convert coordinates to radians
    cat1 = cat1*deg2rad
    cat2 = cat2*deg2rad
    
    # Find ascending declination order of second catalogue
    asc_dec = np.argsort(cat2[:, 1]) #return array of sorted indexes
    cat2_sorted = cat2[asc_dec] #make the sorted catalogue
    dec2_sorted = cat2_sorted[:, 1] #sorted declinations
    
    for id1, (ra1, dec1) in enumerate(cat1):
        closest_dist = np.inf #closest distance bound is infinite
        closest_id2 = None 
        
        # Declination search box; bounds of the declinations to search
        min_dec = dec1 - max_radius 
        max_dec = dec1 + max_radius
        
        # Start and end indices of the search using the numpy binary searching algorithm
        start = dec2_sorted.searchsorted(min_dec, side='left') #gives left most index where the start index is
        end = dec2_sorted.searchsorted(max_dec, side='right') #gives the rightmost index where the end index is
        
        for s_id2, (ra2, dec2) in enumerate(cat2_sorted[start:end+1], start):
            dist = angular_dist_rad(ra1, dec1, ra2, dec2)
            if dist < closest_dist: #finds closest catalogue 2 distance to catalogue 1
                closest_sorted_id2 = s_id2
                closest_dist = dist
        
        # Ignore match if it's outside the maximum radius
        if closest_dist > max_radius:
            no_matches.append(id1) 
        else: #matches the catalogue 1 object and catalogue 2 object if the closest distance is within the threshold
            closest_id2 = asc_dec[closest_sorted_id2]
            matches.append([id1, closest_id2, closest_dist*rad2deg]) 
    
    time_taken = time() - start_time
    return matches, no_matches, time_taken

#Fastest algorithm to use is a k-d tree to seperate all of the dimensional qualities of our catalogue 2 (right ascension and declination) into a 2D tree for searching
#Astropy has done this - will use that library
"""
NOTE: How do K-D trees work?
- makes a tree of all of the values recursively using the median points in one of the k axes
- for one of the dimensions considered (in this case, the right ascension), the median value is taken and the data is split up
- then on the left side, the median of the declination is taken and split up
- then take the median of the right ascension again for all of the points above and below the declination median 
- this process is repeated on the left side until all data points lie on (node) or within (leaf) a part of the tree
- the entire process is then repeated again for the right side of the initial median value; thus constructing a full tree
"""

from astropy.coordinates import SkyCoord
from astropy import units as unit

def crossmatch_kdtree(max_radius, cat1, cats2):
    start_time = time()
    matches = []
    no_matches = []
    
    # Use astropy to convert all of the coordinates into astropy objects in sky coordinates via a kd tree
    cat1_sc = SkyCoord(coords1*unit.degree, frame='icrs')
    cat2_sc = SkyCoord(coords2*unit.degree, frame='icrs')
    
    # Perform crossmatching via the kd tree developed
    closest_ids, closest_dists, other = cat1_sc.match_to_catalog_sky(cat2_sc)
    
    for id1, (closest_id2, dist) in enumerate(zip(closest_ids, closest_dists)): #takes the closest id and closest distance arrays and zips them, then enumerates
        closest_dist = dist.value
        # Ignore match if it's outside the maximum radius
        if closest_dist > max_radius:
            no_matches.append(id1)
        else:
            matches.append([id1, closest_id2, closest_dist])
    
    time_taken = time() - start_time #takes significantly less time
    return matches, no_matches, time_taken